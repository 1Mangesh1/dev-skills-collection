#!/usr/bin/env python3
"""
Test Generator - Generate unit tests from source code.
Creates basic test skeletons for functions and classes.
"""

import re
import json
from typing import List, Dict
from pathlib import Path

class TestGenerator:
    """Generate test cases from source code."""
    
    def __init__(self):
        self.generated_tests = []
    
    def extract_functions(self, source_file: str) -> List[Dict]:
        """Extract function definitions from source code."""
        functions = []
        
        try:
            with open(source_file, 'r') as f:
                source_code = f.read()
            
            # Python function pattern
            pattern = r'def\s+(\w+)\s*\((.*?)\).*?:(?:\n|.*\n)((?:.*?\n)*?)(?=\ndef|\nclass|\Z)'
            
            for match in re.finditer(pattern, source_code, re.DOTALL):
                func_name = match.group(1)
                parameters = match.group(2)
                docstring = self.extract_docstring(match.group(3))
                
                # Parse parameters
                params = [p.strip().split('=')[0].strip() for p in parameters.split(',') if p.strip()]
                
                functions.append({
                    'name': func_name,
                    'parameters': params,
                    'docstring': docstring,
                    'return_type': self.infer_return_type(docstring)
                })
        except Exception as e:
            return []
        
        return functions
    
    def extract_docstring(self, code_snippet: str) -> str:
        """Extract docstring from function code."""
        docstring_pattern = r'^\s*"""(.*?)"""'
        match = re.search(docstring_pattern, code_snippet, re.DOTALL)
        return match.group(1).strip() if match else ""
    
    def infer_return_type(self, docstring: str) -> str:
        """Infer return type from docstring."""
        returns_pattern = r'Returns?:?\s*(\w+)'
        match = re.search(returns_pattern, docstring)
        return match.group(1) if match else "Any"
    
    def generate_test_for_function(self, func: Dict) -> str:
        """Generate unit test for a function."""
        func_name = func['name']
        params = func['parameters']
        
        # Filter out 'self' for methods
        params = [p for p in params if p != 'self']
        
        test_code = f"""
    def test_{func_name}_basic(self):
        \"\"\"Test {func_name} with basic inputs.\"\"\"
        # TODO: Setup test data
        """
        
        if params:
            test_code += f"""
        {', '.join(params)} = ...  # TODO: Define test inputs
        """
        
        test_code += f"""
        # result = {func_name}({', '.join(params)})
        # self.assertIsNotNone(result)
        pass
        
    def test_{func_name}_edge_cases(self):
        \"\"\"Test {func_name} edge cases.\"\"\"
        # TODO: Test with edge inputs (empty, None, etc.)
        pass
        
    def test_{func_name}_error_handling(self):
        \"\"\"Test {func_name} error handling.\"\"\"
        # TODO: Test invalid inputs and expected exceptions
        pass
"""
        return test_code
    
    def generate_test_file(self, source_file: str, test_file: str = None) -> str:
        """Generate complete test file."""
        if test_file is None:
            test_file = source_file.replace('.py', '_test.py')
        
        functions = self.extract_functions(source_file)
        
        # Extract module name
        module_name = Path(source_file).stem
        
        test_code = f'''"""
Unit tests for {module_name}.
Generated by Test Generator.
"""

import unittest
from {module_name} import *

class Test{module_name.title()}(unittest.TestCase):
    \"\"\"Test suite for {module_name} module.\"\"\"
    
    def setUp(self):
        \"\"\"SetUp test fixtures.\"\"\"
        # TODO: Initialize test data and resources
        pass
    
    def tearDown(self):
        \"\"\"Tear down test fixtures.\"\"\"
        # TODO: Clean up resources
        pass
'''
        
        for func in functions:
            test_code += self.generate_test_for_function(func)
        
        test_code += '\n\nif __name__ == "__main__":\n    unittest.main()\n'
        
        return test_code
    
    def estimate_test_effort(self, functions: List[Dict]) -> Dict:
        """Estimate effort to write tests for functions."""
        effort_estimates = {
            'simple': 0.5,      # Hours per function
            'medium': 1,
            'complex': 2,
            'integration': 3
        }
        
        total_functions = len(functions)
        estimated_hours = total_functions * 1  # Default to medium
        
        return {
            'total_functions': total_functions,
            'estimated_hours': estimated_hours,
            'estimated_working_hours': estimated_hours * 1.25,
            'priority_functions': [f['name'] for f in functions if len(f['parameters']) > 3]
        }

def main():
    import sys
    if len(sys.argv) < 2:
        print("Usage: test-generator.py <source_file>")
        sys.exit(1)
    
    generator = TestGenerator()
    test_code = generator.generate_test_file(sys.argv[1])
    print(test_code)

if __name__ == "__main__":
    main()
