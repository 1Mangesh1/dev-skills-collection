#!/usr/bin/env python3
"""
Vulnerability Scanner - Detect security vulnerabilities in dependencies.
Scans for known CVEs and security issues.
"""

import json
import subprocess
import sys
from typing import Dict, List
from dataclasses import dataclass

@dataclass
class Vulnerability:
    """Represent a vulnerability finding."""
    package: str
    current_version: str
    severity: str
    cve_id: str
    description: str
    fixed_version: str
    
    def to_dict(self) -> Dict:
        return {
            'package': self.package,
            'current_version': self.current_version,
            'severity': self.severity,
            'cve_id': self.cve_id,
            'description': self.description,
            'fixed_version': self.fixed_version
        }

class VulnerabilityScanner:
    """Scan dependencies for vulnerabilities."""
    
    def __init__(self):
        self.vulnerabilities: List[Vulnerability] = []
        self.severity_levels = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']
    
    def scan_python_dependencies(self) -> List[Dict]:
        """Scan Python dependencies using pip-audit."""
        try:
            result = subprocess.run(
                ['pip-audit', '--format', 'json'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0 or result.stdout:
                data = json.loads(result.stdout)
                return data.get('vulnerabilities', [])
        except FileNotFoundError:
            print("Warning: pip-audit not installed. Install with: pip install pip-audit")
        except json.JSONDecodeError:
            pass
        
        return []
    
    def scan_npm_dependencies(self) -> List[Dict]:
        """Scan Node.js dependencies using npm audit."""
        try:
            result = subprocess.run(
                ['npm', 'audit', '--json'],
                capture_output=True,
                text=True
            )
            
            data = json.loads(result.stdout)
            vulnerabilities = []
            
            for vuln_data in data.get('vulnerabilities', {}).values():
                if isinstance(vuln_data, dict) and 'severity' in vuln_data:
                    vulnerabilities.append({
                        'package': vuln_data.get('name', ''),
                        'severity': vuln_data.get('severity', '').upper(),
                        'cve': vuln_data.get('cves', [{}])[0].get('id', 'N/A')
                    })
            
            return vulnerabilities
        except FileNotFoundError:
            print("Warning: npm not installed")
        except json.JSONDecodeError:
            pass
        
        return []
    
    def check_exposed_secrets(self, filepath: str) -> List[Dict]:
        """Check for exposed secrets in files."""
        secrets_patterns = {
            'aws_key': r'AKIA[0-9A-Z]{16}',
            'private_key': r'-----BEGIN RSA PRIVATE KEY-----',
            'api_key': r'api[_-]?key["\']?\s*[:=]\s*["\']?[a-zA-Z0-9]{20,}',
            'password': r'password["\']?\s*[:=]',
            'jwt_token': r'eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*',
            'database_url': r'(postgres|mysql|mongodb)://.*@'
        }
        
        secrets_found = []
        
        try:
            with open(filepath, 'r', errors='ignore') as f:
                for line_num, line in enumerate(f, 1):
                    for secret_type, pattern in secrets_patterns.items():
                        import re
                        if re.search(pattern, line):
                            secrets_found.append({
                                'type': secret_type,
                                'file': filepath,
                                'line': line_num,
                                'severity': 'CRITICAL'
                            })
        except FileNotFoundError:
            pass
        
        return secrets_found
    
    def check_ssl_tls_config(self, hostname: str, port: int = 443) -> Dict:
        """Check SSL/TLS configuration."""
        try:
            import ssl
            import socket
            
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    version = ssock.version()
                    
                    return {
                        'hostname': hostname,
                        'port': port,
                        'tls_version': version,
                        'cipher': cipher[0] if cipher else 'N/A',
                        'certificate_subject': cert.get('subject', []),
                        'valid': True
                    }
        except Exception as e:
            return {
                'hostname': hostname,
                'port': port,
                'error': str(e),
                'valid': False
            }
    
    def check_security_headers(self, url: str) -> Dict:
        """Check for security headers in HTTP response."""
        required_headers = {
            'Strict-Transport-Security': 'HSTS',
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': 'Clickjacking protection',
            'Content-Security-Policy': 'CSP',
            'X-XSS-Protection': 'XSS protection'
        }
        
        try:
            import urllib.request
            with urllib.request.urlopen(url, timeout=5) as response:
                headers = dict(response.headers)
                
                missing_headers = []
                found_headers = {}
                
                for header, description in required_headers.items():
                    if header in headers:
                        found_headers[header] = headers[header]
                    else:
                        missing_headers.append({'header': header, 'description': description})
                
                return {
                    'url': url,
                    'found_headers': found_headers,
                    'missing_headers': missing_headers,
                    'security_score': round((len(found_headers) / len(required_headers)) * 100)
                }
        except Exception as e:
            return {
                'url': url,
                'error': str(e)
            }
    
    def generate_security_report(self) -> Dict:
        """Generate comprehensive security report."""
        return {
            'timestamp': __import__('datetime').datetime.utcnow().isoformat(),
            'python_vulnerabilities': self.scan_python_dependencies(),
            'npm_vulnerabilities': self.scan_npm_dependencies(),
            'summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'critical': sum(1 for v in self.vulnerabilities if v.severity == 'CRITICAL'),
                'high': sum(1 for v in self.vulnerabilities if v.severity == 'HIGH'),
                'medium': sum(1 for v in self.vulnerabilities if v.severity == 'MEDIUM')
            }
        }

def main():
    scanner = VulnerabilityScanner()
    report = scanner.generate_security_report()
    print(json.dumps(report, indent=2))

if __name__ == "__main__":
    main()
